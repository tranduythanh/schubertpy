% --- Pieri Type D Algorithms ---

\subsection*{Thuật toán Pieri Type D (Grassmannian trực giao chẵn) -- Python: \texttt{pieriD\_inner}}

\begin{algorithm}[H]
\caption{Pieri Rule Type D (\texttt{pieriD\_inner})}
\begin{algorithmic}[1]
\REQUIRE $p \in \mathbb{Z}$, $\lambda = (\lambda_1, ..., \lambda_l)$, $k, n \in \mathbb{N}$
\ENSURE $\sum \text{Dcoef}(p,\lambda,\mu,t_\lambda,k,n) \sigma_\mu \in H^*(OG(k,2n+2))$
\STATE $result \gets 0$
\STATE $t_\lambda \gets$ TypeParameter($\lambda$, $k$)
\STATE $\mathcal{P} \gets$ PieriSet($|p|$, $\lambda$, $k$, $n$, $1$)
\FOR{mỗi $\mu \in \mathcal{P}$}
    \STATE $coef \gets$ Dcoef($p$, $\lambda$, $\mu$, $t_\lambda$, $k$, $n$)
    \STATE $result \gets result + coef$
\ENDFOR
\RETURN $result$
\end{algorithmic}
\end{algorithm}

\subsection*{Thuật toán hỗ trợ cho Pieri Type D}


% Thuật toán tính hệ số D (Type D Pieri coefficient) - Python: _dcoef

% _dcoef(p, lam, mu, tlam, k, n)
\begin{algorithm}[H]
\caption{Tính hệ số D: \texttt{\_dcoef}(p, $\lambda$, $\mu$, tlam, k, n)}
\begin{algorithmic}[1]
\REQUIRE $p \in \mathbb{Z}$, $\lambda, \mu$ là các partition, $tlam \in \{0,1,2\}$, $k, n \in \mathbb{N}$
\ENSURE Linear combination hệ số cho Pieri Type D
\STATE $\Delta \gets \begin{cases}
    0 & \text{nếu } |p| < k \\
    1 & \text{các trường hợp khác}
\end{cases}$
\STATE $cc \gets \text{count\_comps}(\lambda, \mu, \text{False}, k, 1) - \Delta$
\IF{$cc \geq 0$}
    \STATE $result \gets \begin{cases}
        \sigma_\mu & \text{nếu } k \notin \mu \text{ hoặc } tlam = 1 \\
        \sigma_{\mu + [0]} & \text{nếu } tlam = 2 \\
        \sigma_\mu + \sigma_{\mu + [0]} & \text{ngược lại}
    \end{cases}$
    \RETURN $2^{cc} \cdot result$
\ENDIF
% Tie breaking
\STATE $\Delta \gets \begin{cases}
    1 & \text{nếu } p < 0 \\
    0 & \text{các trường hợp khác}
\end{cases}$
\STATE $h \gets k + tlam + \Delta$
\IF{$tlam = 0$ và $k \in \mu$}
    \RETURN $\begin{cases}
        \sigma_\mu & \text{nếu } h = 0 \\
        \sigma_{\mu + [0]} & \text{nếu } h \neq 0
    \end{cases}$
\ENDIF
\RETURN $\begin{cases}
    0 & \text{nếu } h = 0 \\
    \sigma_{\mu + [0]} & \text{nếu } tlam = 2 \text{ và } k \in \mu \\
    \sigma_\mu & \text{ngược lại}
\end{cases}$
\end{algorithmic}
\end{algorithm}

% Thuật toán tie-breaking value (Python: _tie_breaking_value)
\begin{algorithm}[H]
\caption{Tính tie-breaking value: $\mathtt{\_tie\_breaking\_value}(\lambda, \mu, k, tlam, p)$}
\begin{algorithmic}[1]
\REQUIRE $\lambda, \mu$ là partition, $k, tlam, p \in \mathbb{N}$
\ENSURE $h \in \{0,1\}$
\STATE $h \gets k + tlam + \begin{cases}
    1 & \text{nếu } p < 0 \\
    0 & \text{ngược lại}
\end{cases}$
\STATE $pmu \gets 0$
\FOR{$i$ từ $|\mu|-1$ đến $0$}
    \STATE $lami \gets \begin{cases}
        \lambda[i] & \text{nếu } i < |\lambda| \\
        0 & \text{ngược lại}
    \end{cases}$
    \IF{$lami < \min(\mu[i], k)$}
        \STATE $h \gets h - (\min(\mu[i], k) - \max(pmu, lami))$
    \ENDIF
    \STATE $pmu \gets \mu[i]$
\ENDFOR
\RETURN $h \bmod 2$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{Pieri Set Generation (\texttt{pieri\_set})}
\begin{algorithmic}[1]
\REQUIRE $p \in \mathbb{Z}$, $\lambda = (\lambda_1, ..., \lambda_l)$, $k, n \in \mathbb{N}$
\ENSURE Tập hợp các partition tương ứng với quy tắc Pieri Type D
\STATE $\mathcal{P} \gets \emptyset$
\STATE $\mu \gets$ Partition chuẩn với độ dài $k$
\WHILE{$\mu \neq \emptyset$}
    \STATE $\mathcal{P} \gets \mathcal{P} \cup \{\mu\}$
    \STATE $\mu \gets$ PieriIterD($\mu$, $\lambda$, $k$, $n$)
\ENDWHILE
\RETURN $\mathcal{P}$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{Count Connected Components (\texttt{count\_comps}, skipfirst=false, d=1)}
\begin{algorithmic}[1]
\REQUIRE $\lambda, \mu$ là các partition, $flag \in \{true, false\}$, $k, d \in \mathbb{N}$
\ENSURE Số lượng thành phần liên thông
\STATE $c \gets 0$
\STATE $used \gets$ đánh dấu tất cả các ô của $\lambda$ là chưa sử dụng
\FOR{mỗi ô $u$ trong $\lambda$}
    \IF{$used[u] = false$}
        \STATE $c \gets c + 1$
        \STATE Đánh dấu tất cả các ô liên thông với $u$ là đã sử dụng
    \ENDIF
\ENDFOR
\RETURN $c$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{Pieri Fill Type B/C/D (\texttt{\_pieri\_fill})}
\begin{algorithmic}[1]
\REQUIRE $\lambda$, $inner$, $outer$ là các partition, $row\_index$, $p \in \mathbb{N}$
\ENSURE $\mu$ hoặc $\emptyset$
\IF{$\lambda = \emptyset$}
    \RETURN $\lambda$
\ENDIF
\STATE $res \gets \lambda.copy()$
\STATE $pp \gets p$
\STATE $rr \gets row\_index$
\IF{$ rr = 0 $}
    \STATE $x \gets \min(outer[0], inner[0] + pp)$
    \STATE $res[0] \gets x$
    \STATE $pp \gets pp - x + inner[0]$
    \STATE $rr \gets 1$
\ENDIF
\WHILE{$rr < |\lambda|$}
    \STATE $x \gets \min(outer[rr], inner[rr] + pp, res[rr-1])$
    \STATE $res[rr] \gets x$
    \STATE $pp \gets pp - x + inner[rr]$
    \STATE $rr \gets rr + 1$
\ENDWHILE
\IF{$pp > 0$}
    \RETURN $\emptyset$
\ENDIF
\RETURN $res[:|\lambda|]$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{Pieri Iterator Type B/C/D (\texttt{\_pieri\_itr})}
\begin{algorithmic}[1]
\REQUIRE $\lambda$, $inner$, $outer$ là các partition
\ENSURE $\mu$ hoặc $\emptyset$
\IF{$\lambda = \emptyset$}
    \RETURN $\emptyset$
\ENDIF
\STATE $p \gets \lambda_{|\lambda|} - inner_{|\lambda|}$
\FOR{$r \gets |\lambda|-1$ down to $1$}
    \IF{$\lambda[r] > inner[r]$}
        \STATE $\mu \gets \lambda.copy()$
        \STATE $\mu[r] \gets \mu[r] - 1$
        \STATE $\mu \gets$ PieriFillB($\mu$, $inner$, $outer$, $r+1$, $p+1$)
        \IF{$\mu \neq \emptyset$}
            \RETURN $\mu$
        \ENDIF
    \ENDIF
    \STATE $p \gets p + \lambda[r] - inner[r]$
\ENDFOR
\RETURN $\emptyset$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{Partition Conjugate (\texttt{part\_conj})}
\begin{algorithmic}[1]
\REQUIRE $\lambda = (\lambda_1, ..., \lambda_l)$
\ENSURE $\lambda'$ là phân hoạch liên hợp
\STATE $\lambda' \gets (\lambda_l, ..., \lambda_1)$
\RETURN $\lambda'$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{Part Star Operation (\texttt{\_part\_star})}
\begin{algorithmic}[1]
\REQUIRE $\lambda = (\lambda_1, ..., \lambda_l)$, $cols \in \mathbb{N}$
\ENSURE Schur hoặc $0$
\IF{$\lambda = \emptyset$ hoặc $\lambda_1 \neq cols$}
    \RETURN $0$
\ENDIF
\IF{$|\lambda| = 1$}
    \RETURN $\sigma_{\emptyset}$
\ENDIF
\RETURN $\sigma_{(\lambda_2, ..., \lambda_l)}$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{Part Tilde Operation (\texttt{\_part\_tilde})}
\begin{algorithmic}[1]
\REQUIRE $\lambda = (\lambda_1, ..., \lambda_l)$
\ENSURE $\lambda'$ với các phần tử đã được biến đổi
\STATE $\lambda' \gets \emptyset$
\FOR{$i = 1$ đến $|\lambda|$}
    \STATE $\lambda'[i] \gets \lambda[i] - 2 \cdot (i-1)$
\ENDFOR
\RETURN $\lambda'$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{Dualization Operation (\texttt{dualize})}
\begin{algorithmic}[1]
\REQUIRE $\lambda = (\lambda_1, ..., \lambda_l)$
\ENSURE $\lambda^*$ là phân hoạch đối ngẫu
\STATE $\lambda^* \gets (\lambda_l, ..., \lambda_1)$
\RETURN $\lambda^*$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{Index Dualization (\texttt{dualize\_index\_inner})}
\begin{algorithmic}[1]
\REQUIRE $\lambda = (\lambda_1, ..., \lambda_l)$, $i \in \mathbb{N}$
\ENSURE $\lambda'$ với chỉ số đã được đối ngẫu
\STATE $\lambda' \gets \lambda$
\STATE $\lambda'[i] \gets \lambda[i] - 1$
\RETURN $\lambda'$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{Type Swap Operation (\texttt{type\_swap})}
\begin{algorithmic}[1]
\REQUIRE $\lambda = (\lambda_1, ..., \lambda_l)$
\ENSURE $\lambda'$ với kiểu đã được hoán đổi
\STATE $\lambda' \gets \emptyset$
\FOR{$i = 1$ đến $|\lambda|$}
    \IF{$i$ lẻ}
        \STATE $\lambda'[i] \gets \lambda[i] + 1$
    \ELSE
        \STATE $\lambda'[i] \gets \lambda[i] - 1$
    \ENDIF
\ENDFOR
\RETURN $\lambda'$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{Partition Type Swap (\texttt{type\_swap\_inner})}
\begin{algorithmic}[1]
\REQUIRE $\lambda = (\lambda_1, ..., \lambda_l)$
\ENSURE $\lambda'$ với kiểu đã được hoán đổi
\STATE $\lambda' \gets \emptyset$
\FOR{$i = 1$ đến $|\lambda|$}
    \IF{$i$ lẻ}
        \STATE $\lambda'[i] \gets \lambda[i] - 1$
    \ELSE
        \STATE $\lambda'[i] \gets \lambda[i] + 1$
    \ENDIF
\ENDFOR
\RETURN $\lambda'$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{Quantum Helper: ToSchurFromIntnMu (\texttt{\_toSchurFromIntnMu})}
\begin{algorithmic}[1]
\REQUIRE $i \in \mathbb{N}$, $\lambda = (\lambda_1, ..., \lambda_l)$, $k, n \in \mathbb{N}$
\ENSURE $\sum a_\mu \sigma_\mu + \sum b_\nu q^d \sigma_\nu \in QH^*(Gr(k,n))$
\STATE $result \gets$ PieriA($i$, $\lambda$, $k$, $n$)
\IF{$|\lambda| = n-k$ và $\lambda_{n-k} > 0$}
    \IF{$k = 1$}
        \RETURN $q \cdot \sigma_{\emptyset}$
    \ENDIF
    \STATE $\lambda' \gets \{\lambda_j - 1 : \lambda_j > 1\}$
    \STATE $LC \gets$ PieriA($i-1$, $\lambda'$, $k-1$, $n$)
    \STATE $Z \gets$ ApplyLC($\mu \mapsto$ PartStar($\mu$, $k-1$), $LC$)
    \STATE $result \gets result + q \cdot Z$
\ENDIF
\RETURN $result$
\end{algorithmic}
\end{algorithm}

\subsection*{Thuật toán Pieri lượng tử Type D (Quantum) -- Python: \texttt{qpieriD\_inner}}

\begin{algorithm}[H]
\caption{Quantum Pieri Rule Type D (\texttt{qpieriD\_inner})}
\begin{algorithmic}[1]
\REQUIRE $p \in \mathbb{Z}$, $\lambda = (\lambda_1, ..., \lambda_l)$, $k, n \in \mathbb{N}$
\ENSURE $\sum a_\mu \sigma_\mu + \sum b_\nu q^d \sigma_\nu \in QH^*(OG(k,2n+2))$
\STATE $result \gets$ PieriD($p$, $\lambda$, $k$, $n$) \COMMENT{Số hạng cổ điển}
% TODO: Bổ sung chi tiết các điều kiện lượng tử đặc thù cho Type D nếu có
\RETURN $result$ % (hoặc thêm các số hạng lượng tử nếu có)
\end{algorithmic}
\end{algorithm}