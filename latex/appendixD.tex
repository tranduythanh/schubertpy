% --- Pieri Type D Algorithms ---

\subsection*{Thuật toán Pieri Type D (Grassmannian trực giao chẵn): \texttt{pieriD\_inner} và các thuật toán bổ trợ}

\begin{algorithm}[H]
\caption{Pieri Rule Type D (\texttt{pieriD\_inner})}
\begin{algorithmic}[1]
\REQUIRE $p \in \mathbb{Z}$, $\lambda = (\lambda_1, ..., \lambda_l)$, $k, n \in \mathbb{N}$
\ENSURE $\sum \text{\_dcoef}(p,\lambda,\mu,t_\lambda,k,n) \in H^*(OG(k,2n+2))$
\STATE $\lambda \gets \mathtt{list}(\lambda)$
\STATE $t_\lambda \gets \begin{cases}
0 & \text{nếu } k \notin \lambda \\
2 & \text{nếu } k \in \lambda \text{ và } \lambda_{|\lambda|} = 0 \\
1 & \text{nếu } k \in \lambda \text{ và } \lambda_{|\lambda|} > 0
\end{cases}$
\STATE $\mathcal{P} \gets$ $\mathtt{pieri\_set}$($|p|$, $\lambda$, $k$, $n$, $1$)
\FOR{mỗi $\mu \in \mathcal{P}$}
    \STATE $coef \gets$ $\mathtt{\_dcoef}$($p$, $\lambda$, $\mu$, $t_\lambda$, $k$, $n$)
    \STATE $result \gets result + coef$
\ENDFOR
\RETURN $result$
\end{algorithmic}
\end{algorithm}

\subsection*{Thuật toán hỗ trợ cho Pieri Type D}

\begin{algorithm}[H]
\caption{D Coefficient Calculation (\texttt{\_dcoef})}
\begin{algorithmic}[1]
\REQUIRE $p \in \mathbb{Z}$, $\lambda, \mu$ là các partition, $t_\lambda$ là tham số kiểu, $k, n \in \mathbb{N}$
\ENSURE Hệ số D tương ứng với quy tắc Pieri Type D
\STATE $cc \gets \mathtt{count\_comps}(\lambda, \mu, \mathtt{False}, k, 1) - \begin{cases}
0 & \text{nếu } |p| < k \\
1 & \text{nếu } |p| \geq k
\end{cases}$
\IF{$cc \geq 0$}
    \IF{$k \notin \mu$ hoặc $t_\lambda = 1$}
        \RETURN $2^{cc} \cdot \sigma_\mu$
    \ELSIF{$t_\lambda = 2$}
        \RETURN $2^{cc} \cdot \sigma_{\mu \cup \{0\}}$
    \ELSE
        \RETURN $2^{cc} \cdot (\sigma_\mu + \sigma_{\mu \cup \{0\}})$
    \ENDIF
\ENDIF
\COMMENT{Tie breaking case when $cc < 0$}
\STATE $h \gets k + t_\lambda + \begin{cases}
1 & \text{nếu } p < 0 \\
0 & \text{nếu } p \geq 0
\end{cases}$
\STATE $p_{\mu} \gets 0$
\FOR{$i \gets |\mu|$ down to $1$}
    \STATE $\lambda_i \gets \begin{cases}
    \lambda[i] & \text{nếu } i \leq |\lambda| \\
    0 & \text{nếu } i > |\lambda|
    \end{cases}$
    \IF{$\lambda_i < \min(\mu[i], k)$}
        \STATE $h \gets h - (\min(\mu[i], k) - \max(p_{\mu}, \lambda_i))$
    \ENDIF
    \STATE $p_{\mu} \gets \mu[i]$
\ENDFOR
\STATE $h \gets h \bmod 2$
\IF{$t_\lambda = 0$ và $k \in \mu$}
    \IF{$h = 0$}
        \RETURN $\sigma_\mu$
    \ELSE
        \RETURN $\sigma_{\mu \cup \{0\}}$
    \ENDIF
\ENDIF
\IF{$h = 0$}
    \RETURN $0$
\ENDIF
\IF{$t_\lambda = 2$ và $k \in \mu$}
    \STATE $\mu \gets \mu \cup \{0\}$
\ENDIF
\RETURN $\sigma_\mu$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{Tie-Breaking Value Calculation}
\begin{algorithmic}[1]
\REQUIRE $\lambda, \mu$ là các partition, $t_\lambda$ là tham số kiểu, $k, n \in \mathbb{N}$
\ENSURE Giá trị để phân biệt các trường hợp bằng nhau trong quy tắc Pieri Type D
\STATE $value \gets 0$
\IF{$\lambda = \mu$}
    \RETURN $value$
\ENDIF
\STATE $d \gets \lambda_{|\lambda|} - \mu_{|\mu|}$
\IF{$d > 0$}
    \RETURN $value$
\ENDIF
\STATE $t \gets t_\lambda$
\STATE $t' \gets$ Đảo ngược $t$
\STATE $m \gets \min(|\lambda|, |\mu|)$
\FOR{$i = 1$ đến $m$}
    \IF{$\lambda[i] \neq \mu[i]$}
        \STATE $value \gets t'[i]$
        \RETURN $value$
    \ENDIF
\ENDFOR
\RETURN $value$
\end{algorithmic}
\end{algorithm}




\subsection*{Thuật toán Pieri lượng tử Type D (Quantum): \texttt{qpieriD\_inner} và các thuật toán bổ trợ}

\begin{algorithm}[H]
\caption{Quantum Pieri Rule Type D (\texttt{qpieriD\_inner})}
\begin{algorithmic}[1]
\REQUIRE $p \in \mathbb{Z}$, $\lambda = (\lambda_1, ..., \lambda_l)$, $k, n \in \mathbb{N}$
\ENSURE $\sum a_\mu \sigma_\mu + \sum b_\nu q^d \sigma_\nu \in QH^*(OG(k,2n+2))$
\STATE $\lambda \gets \mathtt{list}(\lambda)$
\STATE $q, q_1, q_2 \gets$ các ký hiệu lượng tử
\STATE $result \gets$ \texttt{pieriD\_inner}($p$, $\lambda$, $k$, $n$)

\IF{$k = 0$}
    \IF{$|\lambda| > 0$ và $\lambda_1 = n + k$}
        \STATE $LC \gets \mathtt{pieriD\_inner}(p, \lambda[2:], k, n)$
        \STATE $f \gets \lambda x \mapsto \mathtt{\_part\_star}(x, n+k)$
        \STATE $term \gets q \cdot \mathtt{apply\_lc}(f, LC)$
        \STATE $result \gets result + term$
    \ENDIF
\ELSIF{$k = 1$}
    \IF{$|\lambda| \geq n$ và $\lambda_n > 0$}
        \STATE $lb \gets \mathtt{part\_clip}([\max(x-1, 0) \text{ for } x \text{ in } \lambda])$
        \STATE $cprd \gets \sigma_{lb}$
        \IF{$|p| > 1$}
            \STATE $cprd \gets \mathtt{pieriD\_inner}(|p|-1, lb, 0, n)$
        \ENDIF
        \STATE $intn \gets \{1, 2, ..., n\}$
        \STATE $f \gets (\lambda \mu \mapsto \mathtt{\_toSchurFromIntnMu}(intn, \mu))$
        \STATE $cprd \gets \mathtt{apply\_lc}(f, cprd)$
        \STATE $res_1 \gets 0$
        \IF{$\lambda_{|\lambda|} > 0$ và $p > 0$}
            \STATE $f \gets (\lambda \mu \mapsto \sigma_{[\mu[i]+1 : i \in \{1..|\mu|\}] \cup [1]^{n-|\mu|}})$
            \STATE $res_1 \gets q_1 \cdot \mathtt{apply\_lc}(f, cprd)$
        \ENDIF
        \IF{($\lambda_{|\lambda|} = 0$ hoặc $k \notin \lambda$) và ($p = -1$ hoặc $p > 1$)}
            \STATE $f \gets (\lambda \mu \mapsto \sigma_{[\mu[i]+1 : i \in \{1..|\mu|\}] \cup [1]^{n-|\mu|} \cup \{0\}})$
            \STATE $res_1 \gets res_1 + q_2 \cdot \mathtt{apply\_lc}(f, cprd)$
        \ENDIF
        \STATE $result \gets result + \mathtt{dualize}(res_1)$
    \ENDIF
    \IF{$|\lambda| > 0$ và $\lambda_1 = n + k$}
        \STATE $LC \gets \mathtt{pieriD\_inner}(p, \lambda[2:], k, n)$
        \STATE $f \gets \lambda x \mapsto \mathtt{\_part\_star}(x, n+k)$
        \STATE $term \gets q_1 \cdot q_2 \cdot \mathtt{apply\_lc}(f, LC)$
        \STATE $result \gets result + term$
    \ENDIF
\ELSE
    \IF{$|\lambda| \geq n+1-k$ và $\lambda_{n+1-k} > 0$}
        \STATE $LC \gets \mathtt{pieriD\_inner}(p, \lambda, k, n+1)$
        \STATE $f \gets \lambda x \mapsto \mathtt{\_part\_tilde}(x, n-k+2, n+k)$
        \STATE $term \gets q \cdot \mathtt{type\_swap}(\mathtt{apply\_lc}(f, LC), k)$
        \STATE $result \gets result + term$
    \ENDIF
    \IF{$|\lambda| > 0$ và $\lambda_1 = n + k$}
        \STATE $LC \gets \mathtt{pieriD\_inner}(p, \lambda[2:], k, n)$
        \STATE $f \gets (\lambda x \mapsto \mathtt{\_part\_star}(x, n+k))$
        \STATE $term \gets q^2 \cdot \mathtt{apply\_lc}(f, LC)$
        \STATE $result \gets result + term$
    \ENDIF
\ENDIF
\RETURN $result$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{Schur from Complement (\texttt{\_toSchurFromIntnMu})}
\begin{algorithmic}[1]
\REQUIRE $intn$ là tập hợp số nguyên, $\mu$ là partition
\ENSURE Schur class từ phần bù của $\mu$ trong $intn$
\STATE $complement \gets intn \setminus \{\mu_i : i \in \{1..|\mu|\}\}$
\STATE $sorted\_complement \gets$ sắp xếp $complement$ theo thứ tự giảm dần
\RETURN $\sigma_{sorted\_complement}$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{Trim Trailing Zeros (\texttt{part\_clip})}
\begin{algorithmic}[1]
\REQUIRE $\lambda = (\lambda_1, ..., \lambda_l)$
\ENSURE $\lambda'$ không có số 0 ở cuối
\STATE $i \gets |\lambda|$
\WHILE{$i > 0$ và $\lambda[i-1] = 0$}
\STATE $i \gets i - 1$
\ENDWHILE
\IF{$i = 0$}
\RETURN $\emptyset$
\ENDIF
\RETURN $(\lambda_1, ..., \lambda_i)$
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
\caption{Dualization Operation (\texttt{dualize})}
\begin{algorithmic}[1]
\REQUIRE $\lambda = (\lambda_1, ..., \lambda_l)$
\ENSURE $\lambda^*$ là phân hoạch đối ngẫu
\STATE $\lambda^* \gets (\lambda_l, ..., \lambda_1)$
\RETURN $\lambda^*$
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
\caption{Type Swap Operation (\texttt{type\_swap})}
\begin{algorithmic}[1]
\REQUIRE $\lambda = (\lambda_1, ..., \lambda_l)$
\ENSURE $\lambda'$ với kiểu đã được hoán đổi
\STATE $\lambda' \gets \emptyset$
\FOR{$i = 1$ đến $|\lambda|$}
    \IF{$i$ lẻ}
        \STATE $\lambda'[i] \gets \lambda[i] + 1$
    \ELSE
        \STATE $\lambda'[i] \gets \lambda[i] - 1$
    \ENDIF
\ENDFOR
\RETURN $\lambda'$
\end{algorithmic}
\end{algorithm}